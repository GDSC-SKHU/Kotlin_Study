## TDD란?

테스트 주도 개발(Test-Driven Development)은 소프트웨어 개발 방법론 중의 하나로, 먼저 자동화된 테스트 코드를 작성한 후 테스트를 통과하기 위한 코드를 개발하는 방식의 개발 방식을 말한다. 매우 짧은 개발 사이클을 반복하는 특징이 있다.

## TDD를 이용한 개발방법
![Untitled](https://blog.kakaocdn.net/dn/mG0Pb/btqBZMj04hL/iFrPHyeudxXYfxkWANylY0/img.png)

1. 테스트 케이스 작성

   :테스트 케이스와 테스트 코드를 작성한다. 테스트 코드가 개발을 주도하기 위해서는 반드시 실패를 포함하는 테스트 코드의 작성이 앞서야 한다.

2. 테스트 케이스를 통과하는 코드 작성

   : 테스트 케이스를 통과하는 코드를 작성한다. 작성된 코드는 개선될 수 있는 많은 여지를 포함한 코드이다.

3. 작성한 코드 리팩토링

   : 마지막으로 리팩토링 단계에서 이를 개선한다.


## TDD의 장점

**객체 지향적인 코드 개발**

- TDD는 코드의 재사용 보장을 명시하므로 TDD를 통한 소프트웨어 개발 시 기능별로 모듈화가 이루어진다. 
- 이는 의존성과 종속성이 낮은 모듈로 조합된 소프트웨어 개발을 가능하게 하며, 필요에 따라 모듈을 추가하거나 제거해도 소프트웨어 전체 구조에 영향을 미치지 않게 된다.

**설계 수정시간의 단축**

- 테스트코드를 먼저 작성하기 때문에 최초 설계안을 만족하게 하며 입출력 구조와 기능의 정의를 명확하게 하게 되므로 설계의 구조적 문제를 바로 찾아낼 수 있다.

**유지보수(리팩토링)의 용이성**

- 기본적으로 단위 테스트 기반의 테스트 코드를 작성하기 때문에 추후 문제가 발생하였을 때 각각의 모듈별로 테스트를 진행해보면 문제의 지점을 쉽게 찾을 수 있다.

**테스트 문서의 대체 가능**

- 대부분의 개발 프로젝트에서 테스트를 진행하는 경우 단순 통합 테스트에 지나지 않는다. 
- TDD를 하게 될 때 테스팅을 자동화시킴과 동시에 더욱 정확한 테스트 근거를 산출해 정의서를 작성할 수 있다.

## TDD의 단점

**사전준비 기간**

- TDD를 프로젝트에 도입하려면 사전에 필요한 지식을 습득하고 개발 환경을 구축해야 한다.

**생산성 저하**

- 프로젝트를 진행할 때 경험 때문에 어떤 예외상황이 발생할지 눈에 뻔히 보이는 경우가 종종 있다. 
- 이러한 단발성 개발은 개발 기간이 타이트하게 잡히는 경우가 많은데, 이럴 때 TDD를 이용해 테스트 코드를 작성하고 그에 통과하기 위한 코드를 작성한다면 비효율적일 것이다.

## **TDD 과연 필요한가?**

[TDD는 항상 옳지 않다 (비용의 문제)](https://architecture101.blog/2014/04/25/tdd-isnot-always-true/)라는 흥미로운 글을 읽었다. 큰 규모의 기업의 경우 TDD를 도입하여 미리 문제를 잡을 수 있는 좋은 보험이 된다는 의견이 많다. 하지만 소규모로 운영되는 스타트업의 경우 리소스적인 측면에서 낭비가 될 수 있는 여지가 크다. 무조건 적용하기보단 상황에 따라 판단하는 것이 좋을 것 같다.

## TDD Tools

**JUnit**

전 세계적으로 널리 사용되는 JAVA의 표준 단위 테스트 프레임워크이다.

**pytest**

Python에서 작고 읽기 쉬운 테스트를 작성할 수 있도록 지원하는 프레임워크이다.

## JUnit 정보

**테스트 어노테이션**

![Untitled](https://velog.velcdn.com/images%2Fjkijki12%2Fpost%2F3fead2f5-45ab-4444-a73d-82f13e93a241%2Fimage.png)

- `@Test`
    - `@Test`가 선언된 메서드는 테스트를 수행하는 메서드가 된다
    - JUnit은 각각의 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 원칙으로 하므로 `@Test`마다 객체를 생성함
- `@Ignore`
    - `@Ignore`가 선언된 메서드는 테스트를 실행하지 않게 함
- `@Before`
    - `@Before`가 선언된 메서드는 `@Test` 메소드가 실행되기 전에 반드시 실행됨
    - `@Test` 메소드에서 공통으로 사용하는 코드를 `@Before`에 선언해 사용할 수 있음
- `@After`
    - `@After`가 선언된 메서드는 `@Test` 메소드가 실행된 후 실행됨
- `@BeforeClass`
    - `@BeforeClass` 어노테이션은 `@Test` 보다 먼저 한 번만 수행되어야 할 경우 사용
- `@AfterClass`
    - `@AfterClass` 어노테이션은 `@Test` 메소드보다 나중에 한 번만 수행되어야 할 경우 사용


**테스트 Assert 메서드**

: 단언한 조건에 부합하지 않으면 테스트를 통과하지 못 한다.

- `assertEquals(a, b)` : 객체 A와 B가 일치함을 확인함
- `assertArrayEquals(a, b)` : 배열 A와 B가 일치함을 확인함
- `assertSame(a, b)` : 객체 A와 B가 같은 객체임을 확인함. `assertEquals` 메서드는 객체의 값이 같은지 확인하는 반면 `assertSame`은 두 객체의 레퍼런스가 같은지 비교
- `assertTrue(a)` : 조건 A가 참인가를 확인
- `assertNotNull(a)` : 객체 A가 null 이 아님을 확인

## Reference

[TDD를 위한 Unit Test](https://wch18735.github.io/junit/JUNIT_Seminar01/)

[테스트 주도 개발](http://www.incodom.kr/%ED%85%8C%EC%8A%A4%ED%8A%B8_%EC%A3%BC%EB%8F%84_%EA%B0%9C%EB%B0%9C)

[TDD 어떻게 하는가?](https://velog.io/@jkijki12/Java-TDD)